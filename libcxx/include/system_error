// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_SYSTEM_ERROR
#define _LIBCPP_SYSTEM_ERROR

/*
    system_error synopsis

namespace std
{

class error_category
{
public:
    virtual ~error_category() noexcept;

    constexpr error_category();
    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;

    virtual const char* name() const noexcept = 0;
    virtual error_condition default_error_condition(int ev) const noexcept;
    virtual bool equivalent(int code, const error_condition& condition) const noexcept;
    virtual bool equivalent(const error_code& code, int condition) const noexcept;
    virtual string message(int ev) const = 0;

    bool operator==(const error_category& rhs) const noexcept;
    bool operator!=(const error_category& rhs) const noexcept;              // removed in C++20
    bool operator<(const error_category& rhs) const noexcept;               // removed in C++20
    strong_ordering operator<=>(const error_category& rhs) const noexcept;  // C++20
};

const error_category& generic_category() noexcept;
const error_category& system_category() noexcept;

template <class T> struct is_error_code_enum
    : public false_type {};

template <class T> struct is_error_condition_enum
    : public false_type {};

template <class _Tp>
inline constexpr bool is_error_condition_enum_v = is_error_condition_enum<_Tp>::value; // C++17

template <class _Tp>
inline constexpr bool is_error_code_enum_v = is_error_code_enum<_Tp>::value; // C++17

class error_code
{
public:
    // constructors:
    error_code() noexcept;
    error_code(int val, const error_category& cat) noexcept;
    template <class ErrorCodeEnum>
        error_code(ErrorCodeEnum e) noexcept;

    // modifiers:
    void assign(int val, const error_category& cat) noexcept;
    template <class ErrorCodeEnum>
        error_code& operator=(ErrorCodeEnum e) noexcept;
    void clear() noexcept;

    // observers:
    int value() const noexcept;
    const error_category& category() const noexcept;
    error_condition default_error_condition() const noexcept;
    string message() const;
    explicit operator bool() const noexcept;
};

// non-member functions:
template <class charT, class traits>
    basic_ostream<charT,traits>&
    operator<<(basic_ostream<charT,traits>& os, const error_code& ec);

class error_condition
{
public:
    // constructors:
    error_condition() noexcept;
    error_condition(int val, const error_category& cat) noexcept;
    template <class ErrorConditionEnum>
        error_condition(ErrorConditionEnum e) noexcept;

    // modifiers:
    void assign(int val, const error_category& cat) noexcept;
    template <class ErrorConditionEnum>
        error_condition& operator=(ErrorConditionEnum e) noexcept;
    void clear() noexcept;

    // observers:
    int value() const noexcept;
    const error_category& category() const noexcept;
    string message() const noexcept;
    explicit operator bool() const noexcept;
};

class system_error
    : public runtime_error
{
public:
    system_error(error_code ec, const string& what_arg);
    system_error(error_code ec, const char* what_arg);
    system_error(error_code ec);
    system_error(int ev, const error_category& ecat, const string& what_arg);
    system_error(int ev, const error_category& ecat, const char* what_arg);
    system_error(int ev, const error_category& ecat);

    const error_code& code() const noexcept;
    const char* what() const noexcept;
};

template <> struct is_error_condition_enum<errc>
    : true_type { }

error_code make_error_code(errc e) noexcept;
error_condition make_error_condition(errc e) noexcept;

// Comparison operators:
bool operator==(const error_code& lhs, const error_code& rhs) noexcept;
bool operator==(const error_code& lhs, const error_condition& rhs) noexcept;
bool operator==(const error_condition& lhs, const error_code& rhs) noexcept;                  // removed in C++20
bool operator==(const error_condition& lhs, const error_condition& rhs) noexcept;
bool operator!=(const error_code& lhs, const error_code& rhs) noexcept;                       // removed in C++20
bool operator!=(const error_code& lhs, const error_condition& rhs) noexcept;                  // removed in C++20
bool operator!=(const error_condition& lhs, const error_code& rhs) noexcept;                  // removed in C++20
bool operator!=(const error_condition& lhs, const error_condition& rhs) noexcept;             // removed in C++20
bool operator<(const error_condition& lhs, const error_condition& rhs) noexcept;              // removed in C++20
bool operator<(const error_code& lhs, const error_code& rhs) noexcept;                        // removed in C++20
strong_ordering operator<=>(const error_code& lhs, const error_code& rhs) noexcept;           // C++20
strong_ordering operator<=>(const error_condition& lhs, const error_condition& rhs) noexcept; // C++20

template <> struct hash<std::error_code>;
template <> struct hash<std::error_condition>;

}  // std

*/

#include <__assert> // all public C++ headers provide the assertion handler
#include <__config>
#include <__format/format_functions.h>
#include <__format/formatter.h>
#include <__format/formatter_integer.h>
#include <__format/formatter_string.h>
#include <__format/parser_std_format_spec.h>
#include <__system_error/errc.h>
#include <__system_error/error_category.h>
#include <__system_error/error_code.h>
#include <__system_error/error_condition.h>
#include <__system_error/system_error.h>
#include <string>
#include <version>

// standard-mandated includes

// [system.error.syn]
#include <compare>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#  pragma GCC system_header
#endif

_LIBCPP_BEGIN_NAMESPACE_STD

#if _LIBCPP_STD_VER >= 26

template <>
struct _LIBCPP_TEMPLATE_VIS formatter<error_category, char> : public formatter<const char*, char> {
  using _Base = formatter<const char*, char>;

  template <class _ParseContext>
  _LIBCPP_HIDE_FROM_ABI constexpr _ParseContext::iterator parse(_ParseContext& __ctx) {
    typename _ParseContext::iterator __result = __parser_.__parse(__ctx, __format_spec::__fields_string_non_truncate);
    __format_spec::__process_display_type_string(__parser_.__type_);
    return __result;
  }

  template <class _FormatContext>
  _LIBCPP_HIDE_FROM_ABI _FormatContext::iterator format(const error_category& __cat, _FormatContext& __ctx) const {
    // Pass by reference since name() is a virtual function.
    // XXX add to paper
    return _Base::format(__cat.name(), __ctx);
  }
};

template <class _Tp>
struct _LIBCPP_TEMPLATE_VIS __error_formatter {
  template <class _ParseContext>
  _LIBCPP_HIDE_FROM_ABI constexpr _ParseContext::iterator parse(_ParseContext& __parse_ctx) {
    // XXX __format_spec::__fields_integral would filter precision, but at a worse error message
    typename _ParseContext::iterator __result = __parser_.__parse(__parse_ctx, __format_spec::__fields_floating_point);
    switch (__parser_.__type_) {
    case __format_spec::__type::__default:
      __parser_.__type_ = __format_spec::__type::__string;
      [[fallthrough]];
    case __format_spec::__type::__string:
    case __format_spec::__type::__debug:
    case __format_spec::__type::__stream_like:
      __parser_.__validate(__format_spec::__fields_string_non_truncate, "an error-class");
      break;

    default:
      __parser_.__validate /*<__format_spec::__type::__binary_lower_case,
                            __format_spec::__type::__binary_upper_case,
                            __format_spec::__type::__decimal,
                            __format_spec::__type::__octal,
                            __format_spec::__type::__hexadecimal_lower_case,
                            __format_spec::__type::__hexadecimal_upper_case>*/
          (__format_spec::__fields_integral, "an error-class", __format_spec::__types_integer);
      break;
    }
    return __result;
  }

  template <class _FormatContext>
  _LIBCPP_HIDE_FROM_ABI _FormatContext::iterator format(_Tp __error, _FormatContext& __ctx) const {
    __format_spec::__parsed_specifications<char> __specs = __parser_.__get_parsed_std_specifications(__ctx);
    switch (__parser_.__type_) {
    case __format_spec::__type::__string:
    case __format_spec::__type::__debug:
      return std::__format_string(string_view{__error.message()}, __ctx, __specs);

    case __format_spec::__type::__stream_like: {
      string __message{std::format("{}:{}", __error.category().name(), __error.value())};
      return std::__format_string(string_view{__message}, __ctx, __specs);
    }

    default:
      return std::__format_integer(__error.value(), __ctx, __specs);
    }
  }

  __format_spec::__parser<char> __parser_;
};

template <>
struct _LIBCPP_TEMPLATE_VIS formatter<error_code, char> : public __error_formatter<error_code> {};
template <>
struct _LIBCPP_TEMPLATE_VIS formatter<error_condition, char> : public __error_formatter<error_condition> {};
#endif // _LIBCPP_STD_VER >= 26

_LIBCPP_END_NAMESPACE_STD

#if !defined(_LIBCPP_REMOVE_TRANSITIVE_INCLUDES) && _LIBCPP_STD_VER <= 20
#  include <cstdint>
#  include <cstring>
#  include <limits>
#  include <type_traits>
#endif

#endif // _LIBCPP_SYSTEM_ERROR
